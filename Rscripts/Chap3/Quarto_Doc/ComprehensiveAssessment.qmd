---
title: "Comprehensive Assessment"
author: "Linh Dang"
format:
  html:
    code-fold: true
    toc: true
    toc-location: left
    toc-depth: 3
editor: visual
---

```{r echo=T, results='hide'}
library(phyloseq)
library(reshape2)
library(microViz)
library(microbiome)
library(vegan)
library(Wrench)
library(tidyverse)
```

```{r}
rm(list = ls())
source("../../add_code/Functions.R")
df_additionalInfo <- readxl::read_xlsx("../../meta/Mice_meta.xlsx")
pseq_raw <- readRDS("../../data/Chap3/pseq_Proj5_postFilter_v04.rds") %>% 
  ps_filter(ffpe.bulk == "bulk") %>% 
  ps_filter(true.control == "true") %>% 
  append_AN_NR(df_additional = df_additionalInfo) %>% 
  WrenchWrapper(grp = "Sex") 
pseq_restrictive <- readRDS("../../data/Chap3/pseq_bulk_restrictive.rds") %>% 
  append_AN_NR(df_additionalInfo) %>% 
  WrenchWrapper(grp = "Sex")
pseq_decontam <- readRDS("../../data/Chap3/pseq_bulk_decontam_p0.5.rds") %>% 
  append_AN_NR(df_additionalInfo) %>% 
  WrenchWrapper(grp = "Sex")
pseq_SCRuB <- readRDS("../../data/Chap3/pseq_bulk_SCRuB.rds") %>% 
  append_AN_NR(df_additionalInfo) %>% 
  WrenchWrapper(grp = "Sex")
pseq_Nj <- readRDS("../../data/Chap3/pseq_bulk_Fisher_v02.rds") %>% 
  append_AN_NR(df_additionalInfo) %>% 
  WrenchWrapper(grp = "Sex")
```

## Comprehensive Assessment of Decontamination Methods

Due to lacking of ground truth or mock community. Here are the alternative assess approaches we could use:

-   Assessment of batch effect removal

-   Divergence from Negative Controls

-   Biologically meaningful of Consensus taxa

-   Overlap with known true taxa / contaminants.

## 1. Assessment of batch effect removal

-   **Main idea**: A good decontamination method should reduce technical variation. In this case is the technician.

-   **Approach:** Perform Ordination (PCoA) and PERMANOVA (adonis2).

-   **Metric:** Check if the variance explained (R2) by "Sequencing Run" or "Extraction Batch" decreases after decontamination.

-   **Logic:** Real tumor microbiomes shouldn't cluster by which technician sequenced.

Write a wrapper

```{r}
library(gridExtra)
### simple ord plot and permanova
assess_batch_effect <- function(ps, method = "PCoA", distance = "bray", batch = "person", gg_title = "raw"){
  ord <- ordinate(ps, method = method, distance = distance)
  #ord_clean <- ordinate(pseq_clean, method = "PCoA", distance = "bray")
  p1 <- plot_ordination(ps, ord, color = batch) + 
  stat_ellipse(type = "norm") + # Adds confidence ellipses per batch
  ggtitle(gg_title) +
  theme_bw()
  ## calc distance 
  dis <- distance(ps, method = distance)
  #dist_clean <- distance(pseq_clean, method = "bray")
  df_meta <- meta(ps)
  set.seed(210488)
  permanova_raw <- adonis2(as.formula(paste0("dis ~ ", batch)), data = df_meta, permutations = 9999)
  res = list(plt = p1, permanova = permanova_raw)
  return(res)
}
```

### Restrictive

#### Assessment by visualization

```{r}
res_raw <- assess_batch_effect(pseq_raw, batch = "person", gg_title = "Raw - Before Decontamination")
res_restrictive <- assess_batch_effect(pseq_restrictive, batch = "person", gg_title = "After Decon. - Restrictive")

# 4. Display side-by-side
grid.arrange(res_raw$plt, res_restrictive$plt, ncol = 2)
```

#### Statistical Quantification by PERMANOVA

```{r}

# --- PRINT RESULTS ---
print("--- RAW DATA BATCH EFFECT ---")
print(res_raw$permanova)

print("--- CLEAN DATA BATCH EFFECT ---")
print(res_restrictive$permanova)
```

### Decontam

#### Assessment by visualization

```{r}
res_decontam <- assess_batch_effect(pseq_decontam, gg_title = "After Decon. - Decontam")
grid.arrange(res_raw$plt, res_decontam$plt, ncol = 2)
```

#### Statistical Quantification by PERMANOVA

```{r}
# --- PRINT RESULTS ---
print("--- RAW DATA BATCH EFFECT ---")
print(res_raw$permanova)

print("--- CLEAN DATA BATCH EFFECT ---")
print(res_decontam$permanova)
```

### SCRuB

#### Assessment by visualization

```{r}
res_SCRuB <- assess_batch_effect(pseq_SCRuB, gg_title = "After Decon. - SCRuB")
grid.arrange(res_raw$plt, res_SCRuB$plt, ncol = 2)
```

#### Statistical Quantification by PERMANOVA

```{r}
# --- PRINT RESULTS ---
print("--- RAW DATA BATCH EFFECT ---")
print(res_raw$permanova)

print("--- CLEAN DATA BATCH EFFECT ---")
print(res_SCRuB$permanova)
```

### Nejman

#### Assessment by visualization

```{r}
res_Nj <- assess_batch_effect(pseq_Nj, gg_title = "After Decon. - Nejman")
grid.arrange(res_raw$plt, res_Nj$plt, ncol = 2)
```

#### Statistical Quantification by PERMANOVA

```{r}
# --- PRINT RESULTS ---
print("--- RAW DATA BATCH EFFECT ---")
print(res_raw$permanova)

print("--- CLEAN DATA BATCH EFFECT ---")
print(res_Nj$permanova)
```

### Overall Results

```{r}
df_overall_R2_pval <- tibble(Method = character(0),
                             R2 = double(0),
                             p_value = double(0))
df_overall_R2_pval <- df_overall_R2_pval %>% 
  add_row(Method = "Raw", R2 = res_raw$permanova$R2[1], p_value = res_raw$permanova$`Pr(>F)`[1]) %>% 
  add_row(Method = "Restrictive", R2 = res_restrictive$permanova$R2[1], p_value = res_restrictive$permanova$`Pr(>F)`[1]) %>% 
  add_row(Method = "decontam", R2 = res_decontam$permanova$R2[1], p_value = res_decontam$permanova$`Pr(>F)`[1]) %>% 
  add_row(Method = "SCRuB", R2 = res_SCRuB$permanova$R2[1], p_value = res_SCRuB$permanova$`Pr(>F)`[1]) %>% 
  add_row(Method = "Nejman", R2 = res_Nj$permanova$R2[1], p_value = res_Nj$permanova$`Pr(>F)`[1])
print(df_overall_R2_pval)
```

Conclusion: For this dataset, this is not the method we like to choose.

## 2. Divergence from Negative Controls

-   **Approach:** perform Inter-group dissimilarity and Wilcox paired test, following by visualization.

-   **Metric:** Calculate the Jensen-Shannon Divergence (or Bray-Curtis) between samples and the pool of negative controls.

-   **Logic:** the decontamination method should maximize the dissimilarity between true PDAC samples and NCTs.

```{r}
rm(list = ls())
pseq_nct <- readRDS("../../data/Chap3/pseq_Proj5_postFilter_v04.rds") %>% 
  ps_filter(ffpe.bulk == "bulk") %>% 
  ps_filter(true.control != "true")
```

Because we could not apply wrench normalization for NCTs, thus we have to use rarefaction

```{r echo=T, results='hide'}
s_size <- 5000
pseq_raw_both <- readRDS("../../data/Chap3/pseq_Proj5_postFilter_v04.rds") %>% 
  ps_filter(ffpe.bulk == "bulk") %>% 
  rarefy_even_depth(sample.size = s_size)
pseq_restrictive_both <- readRDS("../../data/Chap3/pseq_bulk_restrictive.rds") %>% 
  merge_phyloseq(pseq_nct) %>% 
  rarefy_even_depth(sample.size = s_size)
pseq_decontam_both <- readRDS("../../data/Chap3/pseq_bulk_decontam_p0.5.rds") %>% 
  merge_phyloseq(pseq_nct) %>% 
  rarefy_even_depth(sample.size = s_size)
pseq_SCRuB_both <- readRDS("../../data/Chap3/pseq_bulk_SCRuB.rds") %>% 
  merge_phyloseq(pseq_nct) %>% 
  rarefy_even_depth(sample.size = s_size)
pseq_Nj_both <- readRDS("../../data/Chap3/pseq_bulk_Fisher_v02.rds") %>% 
  merge_phyloseq(pseq_nct) %>% 
  rarefy_even_depth(sample.size = s_size)
```

Write a wrapper

```{r}
get_dist_to_controls <- function(ps, group_col, true_label = "true", control_label = "NCT", metric = "bray"){
  if(tolower(metric) == "jsd") {
    ps <- transform_sample_counts(ps, function(x) x / sum(x))
  }
  dist_mat <- ps %>% 
    distance(method = metric) %>% 
    as.matrix()
  #print(dist_mat)
  meta <- meta(ps)
  true_ids <- rownames(meta)[meta[[group_col]] == true_label]
  ctrl_ids <- rownames(meta)[meta[[group_col]] == control_label]
  #print(ctrl_ids)
  sub_mat <- dist_mat[true_ids, ctrl_ids, drop = FALSE]
  #print(sub_mat)
  mean_dists <- rowMeans(sub_mat, na.rm = TRUE)
  #print(mean_dists)
  median_dists <- apply(sub_mat, 1, median, na.rm = TRUE)
  #print(median_dists)
  return(data.frame(SampleID = names(mean_dists), MeanDist = mean_dists, MedianDist = median_dists))
}
### Wrapper of statistics and ggplots
wrapper_dist_to_controls <- function(ps_raw, ps_clean, group_col, true_label = "true", control_label = "NCT", metric = "bray", decontam_name = "None"){
  df_raw <- get_dist_to_controls(ps_raw, group_col, true_label, control_label, metric)
  df_clean <- get_dist_to_controls(ps_clean, group_col, true_label, control_label, metric)
  df_raw <- df_raw %>% select(SampleID, MeanDist_raw = MeanDist)
  df_clean <- df_clean %>% select(SampleID, MeanDist_clean = MeanDist)
  #print()
  df_stats <- merge(df_raw, df_clean, by = "SampleID")
  test_results <- wilcox.test(df_stats$MeanDist_clean, df_stats$MeanDist_raw,
                            paired = TRUE, alternative = "greater")
  df_long <- melt(df_stats, id.vars="SampleID", measure.vars=c("MeanDist_raw", "MeanDist_clean"))
  plt <- ggplot(df_long, aes(x=variable, y=value, fill=variable)) +
  geom_boxplot(alpha=0.6) +
  geom_point(aes(group=SampleID), alpha=0.5) + # Adds the dots
  geom_line(aes(group=SampleID), alpha=0.2) +  # Connects the dots (shows paired change)
  theme_bw() +
  labs(title = "Divergence from Negative Controls",
       subtitle = paste("P-value:", format.pval(test_results$p.value, digits=4)),
       y = "Mean JSD to Negative Controls",
       x = "Method Stage") +
  scale_x_discrete(labels=c("Raw", decontam_name))
  return(list(test_results = test_results, plt = plt))
}
```

### Raw

```{r}
## calc distnace of each sample to negative control group
df_raw <- get_dist_to_controls(pseq_raw_both, group_col = "true.control",
                               true_label = "true", control_label = "NCT",
                               metric = "jsd")
df_raw <- df_raw %>% 
  rename(MeanDist_raw = MeanDist, MedianDist_raw = MedianDist)
```

### Restrictive

```{r}
res <- wrapper_dist_to_controls(pseq_raw_both, pseq_restrictive_both,
                                group_col = "true.control", 
                                true_label = "true", control_label = "NCT",
                                metric = "jsd", decontam_name = "Restrictive")
print(res$test_results)
```

GGplot

```{r}
res$plt
```

### Decontam

```{r}
res <- wrapper_dist_to_controls(pseq_raw_both, pseq_decontam_both,
                                group_col = "true.control", 
                                true_label = "true", control_label = "NCT",
                                metric = "jsd", decontam_name = "decontam")
print(res$test_results)
```

GGplot

```{r}
res$plt
```

### SCRuB

```{r}
res <- wrapper_dist_to_controls(pseq_raw_both, pseq_SCRuB_both,
                                group_col = "true.control", 
                                true_label = "true", control_label = "NCT",
                                metric = "jsd", decontam_name = "SCRuB")
print(res$test_results)
```

```{r}
res$plt
```

### Nejman

```{r}
res <- wrapper_dist_to_controls(pseq_raw_both, pseq_Nj_both,
                                group_col = "true.control", 
                                true_label = "true", control_label = "NCT",
                                metric = "jsd", decontam_name = "Nejman")
print(res$test_results)
```

```{r}
res$plt
```

Conclusion: all method performer well!

## 3. Biologically meaningful of Consensus taxa

## 4. Overlap with known true taxa / contaminants

-   **Approach:** design a measure quantifying the quality of decontamination approach by balancing the yield and purity explained below.

-   **Metric: Yield** -\> number of putative significant true taxa not in NCTs / number of observed species. **Purity** -\> number of putative significant true taxa not in NCTs / whole number of putative contaminants.

-   **Logic:** a good decontamination methods should give results whose taxa is less overlap with known high prevalence contaminants in large set of NCTs, while not over-removing true taxa.

In the analysis, we investigate 3 defined methods for putative significant true taxa. The season: even though after decontamination, not all remained taxa are significant and play important rules.

```{r}
library(lme4)       # Linear Mixed Models (for repeated measures)
library(lmerTest)   # P-values for Mixed Models
library(emmeans)    # Pairwise comparisons
rm(list = ls())
df_all <- read_table("../../results/Chap3/survey_overlap_NCT/df_all_FisherV02_concat.tsv")
```

For each of a method, we will conduct the following analyses:

-   Visualization of the data.

-   Linear Mixed Model (LMM) where *fixed effect* is decontamination methods, and *random effect* is SampleID (Accounting for biological variation between samples).

-   Perform pairwise comparisons.

### Method 1: Abundance-based Approach

Significant taxa are ones whose abundance are at least 1 percent.

```{r}
df_analysis <- df_all %>%
  select(SampleID, Method, observed, B = NumAbund_1Per, C = NumInNCT_Abd) %>% 
  mutate(
    # 1. Calculate "Clean Species" count
    Clean_Count = B - C,
    
    # 2. Calculate Yield: (Clean Species / Original Total)
    Yield = Clean_Count / observed,
    
    # 3. Calculate Purity: (Clean Species / Total Kept)
    # If Col_B_Kept is 0, Purity is 0
    Purity = ifelse(B > 0, Clean_Count / B, 0),
    
    # 4. COMPOSITE METRIC: Penalized Clean Yield
    # This rewards keeping good data AND having a clean final table
    Composite_Score = Yield * Purity
  )

# Inspect the calculated metric
head(df_analysis)
```

Visualization

```{r}
ggplot(df_analysis, aes(x = Method, y = Composite_Score, fill = Method)) +
  geom_boxplot(alpha = 0.6, outlier.shape = NA) +
  geom_point(position = position_jitter(width = 0.1), alpha = 0.5) +
  # Connect lines for the same sample to show paired changes
  geom_line(aes(group = SampleID), color = "gray", alpha = 0.5) +
  theme_minimal() +
  labs(
    title = "Comparison of Decontamination Methods",
    subtitle = "Metric: Penalized Clean Yield (Higher is Better)",
    y = "Composite Score\n(Yield x Purity)"
  ) +
  theme(legend.position = "none")
```

```{r}
model <- lmer(Composite_Score ~ Method + (1|SampleID), data = df_analysis)

# Check assumptions (Residuals should be roughly normal)
qqnorm(resid(model))
qqline(resid(model))
```

The normality assumption of residual for LMM is almost satisfied.

```{r}
## ANOVA
print(anova(model))
```

Pairwise

```{r}
# Perform pairwise comparisons with Tukey adjustment for multiple testing
emm <- emmeans(model, specs = pairwise ~ Method)

cat("\n=== Pairwise Differences ===\n")
print(emm$contrasts)
```

```{r}
cat("\n=== emmeans ===\n")
print(emm$emmeans)
```

Conclusion: For this method, SCRuB seem to be outperform others.

### Method 2: Prevalence-based Approach

Taxa with prevalence 50% are considered significant

```{r}
df_analysis <- df_all %>%
  select(SampleID, Method, observed, B = NumPrev_50Per, C = NumInNCT_prev) %>% 
  mutate(
    # 1. Calculate "Clean Species" count
    Clean_Count = B - C,
    
    # 2. Calculate Yield: (Clean Species / Original Total)
    Yield = Clean_Count / observed,
    
    # 3. Calculate Purity: (Clean Species / Total Kept)
    # If Col_B_Kept is 0, Purity is 0
    Purity = ifelse(B > 0, Clean_Count / B, 0),
    
    # 4. COMPOSITE METRIC: Penalized Clean Yield
    # This rewards keeping good data AND having a clean final table
    Composite_Score = Yield * Purity
  )

# Inspect the calculated metric
head(df_analysis)
```

```{r}
ggplot(df_analysis, aes(x = Method, y = Composite_Score, fill = Method)) +
  geom_boxplot(alpha = 0.6, outlier.shape = NA) +
  geom_point(position = position_jitter(width = 0.1), alpha = 0.5) +
  # Connect lines for the same sample to show paired changes
  geom_line(aes(group = SampleID), color = "gray", alpha = 0.5) +
  theme_minimal() +
  labs(
    title = "Comparison of Decontamination Methods",
    subtitle = "Metric: Penalized Clean Yield (Higher is Better)",
    y = "Composite Score\n(Yield x Purity)"
  ) +
  theme(legend.position = "none")
```

```{r}
model <- lmer(Composite_Score ~ Method + (1|SampleID), data = df_analysis)

# Check assumptions (Residuals should be roughly normal)
qqnorm(resid(model))
qqline(resid(model))
```

The normality assumption for LMM here is satisfied perfectly.

```{r}
## ANOVA
print(anova(model))
```

Pairwise

```{r}
# Perform pairwise comparisons with Tukey adjustment for multiple testing
emm <- emmeans(model, specs = pairwise ~ Method)

cat("\n=== Pairwise Differences ===\n")
print(emm$contrasts)
```

```{r}
cat("\n=== emmeans ===\n")
print(emm$emmeans)
```

Conclusion: Nejman procedure with Fisher exact test outperforms the rest.

### Method 3: Combination of Abundance and Prevalence

Combine two above methods.

```{r}
df_analysis <- df_all %>%
  select(SampleID, Method, observed, B = NumPrev_Abd, C = NumInNCT_both) %>% 
  mutate(
    # 1. Calculate "Clean Species" count
    Clean_Count = B - C,
    
    # 2. Calculate Yield: (Clean Species / Original Total)
    Yield = Clean_Count / observed,
    
    # 3. Calculate Purity: (Clean Species / Total Kept)
    # If Col_B_Kept is 0, Purity is 0
    Purity = ifelse(B > 0, Clean_Count / B, 0),
    
    # 4. COMPOSITE METRIC: Penalized Clean Yield
    # This rewards keeping good data AND having a clean final table
    Composite_Score = Yield * Purity
  )

# Inspect the calculated metric
head(df_analysis)
```

```{r}
ggplot(df_analysis, aes(x = Method, y = Composite_Score, fill = Method)) +
  geom_boxplot(alpha = 0.6, outlier.shape = NA) +
  geom_point(position = position_jitter(width = 0.1), alpha = 0.5) +
  # Connect lines for the same sample to show paired changes
  geom_line(aes(group = SampleID), color = "gray", alpha = 0.5) +
  theme_minimal() +
  labs(
    title = "Comparison of Decontamination Methods",
    subtitle = "Metric: Penalized Clean Yield (Higher is Better)",
    y = "Composite Score\n(Yield x Purity)"
  ) +
  theme(legend.position = "none")
```

```{r}
model <- lmer(Composite_Score ~ Method + (1|SampleID), data = df_analysis)

# Check assumptions (Residuals should be roughly normal)
qqnorm(resid(model))
qqline(resid(model))
```

Normality assumption does not fit at the tails.

```{r}
## ANOVA
print(anova(model))
```

Pairwise

```{r}
# Perform pairwise comparisons with Tukey adjustment for multiple testing
emm <- emmeans(model, specs = pairwise ~ Method)

cat("\n=== Pairwise Differences ===\n")
print(emm$contrasts)
```

```{r}
cat("\n=== emmeans ===\n")
print(emm$emmeans)
```

Conclusion: Nejman procedure and restrictive seem to perform well.
