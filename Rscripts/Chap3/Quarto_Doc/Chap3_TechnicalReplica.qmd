---
title: "PDAC technical replica"
author: "AG Neesse - Linh Dang"
editor: visual
execute:
  warning: false
  message: false
format:
  html:
    code-fold: true
    toc: true
    toc-location: left
    toc-depth: 5
    toc-expand: 2
    toc-title: Contents
    fig-responsive: true
    fig-lightbox: true
---

**Library**

```{r message=FALSE}
library(phyloseq)
library(reshape2)
library(microViz)
library(microbiome)
library(vegan)
library(lme4)       # Linear Mixed Models (for repeated measures)
library(lmerTest)   # P-values for Mixed Models
library(emmeans)    # Pairwise comparisons
library(Wrench)
library(rstatix)
library(ggpubr)
library(tidyverse)
library(VennDiagram)
library(ComplexUpset)
rm(list = ls())
```

**Functions**

```{r echo=TRUE}
Kolors <- c("#9d547c","#56ca63","#a357d6","cornflowerblue","#419d2a","sandybrown","red3","peachpuff","cyan","paleturquoise3","mistyrose","mediumpurple","mediumseagreen","mediumorchid","moccasin","orange4","olivedrab","midnightblue","papayawhip","palevioletred4","brown1","greenyellow","orchid","navy","darkred","navajowhite1","mistyrose1","grey85","#525fd6","red2","#8cbe3a","#c944aa","indianred3","#5ba557","#9e66cb","#c1b735","#6d82ec","grey25","#e69728","#6654b0","lightsalmon3","lightcyan1","khaki1","seagreen1","plum1","lightsteelblue1","palevioletred3","mintcream","magenta3","#799330","#da7fdf","#3c782c","#e44586","blue4","#63c996","#dc3f53","#49cbc8","#cf3f29","#4fabda","#da6c2b","#598bd1","#b78c24","#8d4191","#a0b971","slategray1","sienna","plum1","lightyellow1","lightskyblue3","linen","limegreen","cornsilk1","mediumaquamarine","gray14","gold3","darkviolet","#b2386a","#479d71","#ae4341","#2ba198","#e07557","#5361a3","#dda353","#aa98df","#5b6114","#dc89bf","#327243","slateblue1","#e57b94","#277257","#9b62a0","#bbab59","#98495a","#526229","#d8827d","#857624","gray40","#9a4a22","#7c7d46","mediumslateblue","lemonchiffon1","#e3a073","#9e6b33", "gray74","slateblue1","rosybrown3", "lawngreen","gainsboro","dodgerblue3","deeppink3","firebrick3", "orchid2", "olivedrab1", "ivory3", "darkseagreen", "bisque2", "darkgoldenrod2", "blue2", "skyblue", "seashell2", "turquoise", "tan1", "seagreen2", "palevioletred3", "linen", "steelblue4","ghostwhite","dodgerblue1","deeppink1","firebrick1", "limegreen", "purple3", "khaki3", "snow3", "darkslategray","darkorchid","lavender", "magenta2", "palegreen", "salmon", "maroon", "cyan2","#671408","#FAEBD7","#7FFFD4","#F0FFFF","#A52A2A","burlywood","cadetblue","#7FFF00","chocolate","cornsilk","slateblue1","#FF7F50","red1","#008B8B","darkgoldenrod1","darkolivegreen","darkorange4","white","hotpink","honeydew1","goldenrod2","darkgreen","oldlace","darkslategray3","navajowhite3","orchid4","gray25","#F0924D")
WrenchWrapper <- function(PhyloObjct, grp, roundUp = F){
  cnt_table <- PhyloObjct %>% otu_table()
  group <- PhyloObjct %>% sample_data() %>% pull(grp)
  w <- wrench(cnt_table, condition = group)
  
  # deseq.obj <- DESeqDataSetFromMatrix(cnt_table %>% as.data.frame(), DataFrame(group), ~group)
  # DESeq2::sizeFactors(deseq.obj) <- w$nf
  # cnt_table_normalized <- DESeq2::counts(deseq.obj, normalized=TRUE)
  
  norm_factors <- w$nf
  norm_counts <- sweep(cnt_table, 2, norm_factors, FUN = '/')
  if(roundUp){norm_counts <- norm_counts %>% round()}
  if(!is.null(phy_tree(PhyloObjct, errorIfNULL = F))){
    return(phyloseq(otu_table(norm_counts, taxa_are_rows = T), tax_table(PhyloObjct %>% tax_table()), sample_data(PhyloObjct %>% sample_data()),
                    phy_tree(PhyloObjct)))
  } else{
    return(phyloseq(otu_table(norm_counts, taxa_are_rows = T), tax_table(PhyloObjct %>% tax_table()), sample_data(PhyloObjct %>% sample_data())))
  }
}
##
append_AN_NR <- function(pseq, df_additional){
  df_meta <- meta(pseq)
  if(!"AN_NR" %in%  colnames(df_meta)){
    print("There must be AN_NR column!")
    return(NA)
  }
  ## check if info is already in the main data frame, warning if already exits
  col_names_fea <- setdiff(colnames(df_additional), "AN_NR")
  new_col_names_fea <- setdiff(col_names_fea, colnames(df_meta))
  if(length(new_col_names_fea)==0){
    warning("All new feature already exits, nothing to be added")
    return(pseq)
  }
  if(length(new_col_names_fea) < length(col_names_fea)){
    warning("partially info already there, add the rest!")
    df_additional <- df_additional %>% 
      select(c("AN_NR", new_col_names_fea))
  }
  
  df_meta_new <- df_meta %>% 
    rownames_to_column(var = "SampleName") %>% 
    left_join(., df_additional, by = "AN_NR") %>% 
    column_to_rownames(var = "SampleName")
  sample_data(pseq) <- df_meta_new
  return(pseq)
}
## alpha plot function with LMM with fixed and random variables
AlphaPlot_Violin_LMM <- function(df, SampleID, strata, val, metric = "Obsered species"){
  ## df: in pivot longer manner
  ## calc p value in manner of paired
  ## get y.position for ggplot
  y_pos <- t_test(formula = as.formula(sprintf("%s ~ %s", val, strata)), data = df) %>% add_xy_position() %>% pull(y.position)
  model <- lmer(as.formula(sprintf("%s ~ %s + (1|%s)", val, strata, SampleID)), data = df)
  emm <- emmeans(model, specs = as.formula(sprintf("pairwise ~ %s", strata)))
  contr <- contrast(emm, method = "pairwise")
  
  p_add <- contr %>% 
    as_tibble() %>%
    transmute(
      group1 = sub(" - .*", "", contrast),
      group2 = sub(".* - ", "", contrast),
      estimate,
      se = SE,
      statistic = t.ratio,
      df,
      p = p.value
      ##method = "emmeans model-based t-test"
    ) %>% 
    add_significance() %>% 
    mutate(y.position = y_pos)
  plt <- ggplot(df, aes(x = .data[[strata]], y = .data[[val]], fill = .data[[strata]])) +
    geom_violin() +
    #geom_boxplot(alpha = 0.6, outlier.shape = NA) +
    geom_boxplot(width=0.2) +
    geom_point(position = position_jitter(width = 0.1), alpha = 0.5) +
    # Connect lines for the same sample to show paired changes
    geom_line(aes(group = AN_NR), color = "gray", alpha = 0.5) +
    theme_minimal() +
    labs(
      title = "Comparison of Decontamination Methods",
      subtitle = sprintf("Alpha Diversity: %s", metric),
      y = metric
    ) +
    theme(legend.position = "none")
  plt <- plt + stat_pvalue_manual(p_add, label = "p.signif", inherit.aes = FALSE, tip.length = 0.01)
  return(list(plt = plt, const = contr))
}

## alpha plot with Wilcon_test
AlphaPlot_Violin_Wilcox <- function(df, SampleID, strata, val, y_label = "Obsered species", subtitle = "The higher the better", ...){
  ## df: in pivot longer manner
  ## calc p value in manner of paired
  ## get y.position for ggplot
  p_add <- wilcox_test(formula = as.formula(sprintf("%s ~ %s", val, strata)), data = df, paired = TRUE, ...) %>% add_significance() %>%  add_xy_position() ##%>% pull(y.position)
  
  plt <- ggplot(df, aes(x = .data[[strata]], y = .data[[val]], fill = .data[[strata]])) +
    geom_violin() +
    #geom_boxplot(alpha = 0.6, outlier.shape = NA) +
    geom_boxplot(width=0.2) +
    geom_point(position = position_jitter(width = 0.1), alpha = 0.5) +
    # Connect lines for the same sample to show paired changes
    geom_line(aes(group = AN_NR), color = "gray", alpha = 0.5) +
    theme_minimal() +
    labs(
      title = "Paired Wilcox test",
      subtitle = subtitle,
      y = y_label
    ) +
    theme(legend.position = "none")
  plt <- plt + stat_pvalue_manual(p_add, label = "p.adj.signif", inherit.aes = FALSE, tip.length = 0.01)
  return(plt)
}
##------------
set_size = function(w, h, factor=1.5) {
    s = 1 * factor
    options(
        repr.plot.width=w * s,
        repr.plot.height=h * s,
        repr.plot.res=100 / factor,
        jupyter.plot_mimetypes='image/png',
        jupyter.plot_scale=1
    )
}

#### create comp_barplot function wrapping 3 properties
CompositionalPlot_Viz_v02 <- function(PhyloseqObj, 
                                      supper_rank='phylum', 
                                      smaller_rank = "family",
                                      ##target_taxa_name = "Sphingomonadaceae",
                                      supper_rank_list = NULL,
                                      facet = NULL, each_num = 4, tax_order_by = sum,
                                      my_title="Bacterial Composition",
                                      my_subtitle = ""){
  hueRank <- supper_rank
  hueRankPlural <- switch (hueRank,
    "phylum" = "phyla",
    "class" = "classes",
    "order" = "orders",
    "family" = "families",
    "genus" = "genera"
  )
  shadeRank <- smaller_rank
  my_order <- supper_rank_list

  # Sort phyloseq at lower, and then higher ranks
  pseq2 <- PhyloseqObj %>%
    #ps_filter(gender == "male") %>%
    tax_sort(by = tax_order_by, at = shadeRank) %>%
    tax_sort(by = tax_order_by, at = hueRank) %>%
    tax_agg(rank = shadeRank)

  ## sort taxa
  tax_tbl <- tax_tibble(pseq2) %>% 
    dplyr::arrange(match(.data[[hueRank]], my_order)) %>% 
    remove_rownames() %>% 
    column_to_rownames(var = "FeatureID")
  pseq2 <- pseq2 %>% 
    tax_reorder(tax_order = rownames(tax_tbl))

  # Specify number of hues and shades desired
  nHues <- length(supper_rank_list) # "Other" phyla will be shades of grey
  nShades <- each_num # "Other" families will be the lightest shade of each hue
  
  hierarchicalPalInfo <- data.frame(
    hue = as.vector(tt_get(pseq2)[, hueRank]),
    shade = as.vector(tt_get(pseq2)[, shadeRank]),
    counts = taxa_sums(otu_get(pseq2))
  )

  hierarchicalPalInfo <- hierarchicalPalInfo %>%
    dplyr::mutate(
      hue = forcats::fct_other(
        f = hue, keep = unique(hue)[seq_len(nHues)],
        other_level = paste("Other", hueRankPlural)
      ),
      nChrHue = nchar(as.character(hue)), padHue = max(nChrHue) - nChrHue
    ) %>%
    dplyr::group_by(hue) %>%
    dplyr::mutate(
      shade = forcats::fct_other(
        f = shade, keep = unique(shade)[seq_len(nShades - 1)],
        other_level = "Other"
      )
    ) %>%
    dplyr::ungroup() %>%
    dplyr::mutate(
      nChrShade = nchar(as.character(shade)), padShade = max(nChrShade) - nChrShade,
      Taxa = paste0(hue, ": ", strrep(" ", padHue), shade, strrep(" ", padShade))
    )

  hierarchicalPalMatrix <- matrix(
  data = sapply(
    X = seq(from = 30, to = 75, length.out = nShades),
    FUN = function(l) scales::hue_pal(l = l, h.start = 30)(n = nHues)
    ),
    byrow = TRUE, ncol = nHues
  )
  hierarchicalPalMatrix <- cbind(hierarchicalPalMatrix, grey.colors(n = nShades))

  hierarchicalPal <- hierarchicalPalMatrix %>%
    as.vector() %>%
    setNames(unique(hierarchicalPalInfo$Taxa))
  
  #############################
  # tax_mutate(!!col_nm := hierarchicalPalInfo$Taxa, .keep = "none") %>% 
  # ps_arrange(AN_NR) %>% 
  # ps_mutate(AN_NR = factor(AN_NR, rev(unique(AN_NR)))) %>% 
  # comp_barplot(
  #   tax_level = col_nm, n_taxa = length(hierarchicalPal),
  #   sample_order = "asis", x = "AN_NR",
  #   tax_order = "asis",
  #   palette = hierarchicalPal, bar_width = 0.975
  # ) +
  # facet_wrap(facets = vars(Replica), scales = "fixed") +
  # coord_flip() +
  # labs( x= "Sample ID", y = "Relative abundance") +
  # scale_y_continuous(expand = expansion(add = c(0, 0.05))) + # axis starts exactly at 0
  # theme_bw() + # slightly clearer axes for facets
  # theme(panel.spacing.x = unit(6, "mm")) # space for non-overlapping axis numbers
  #############################
  
  col_nm <- sprintf("%s: %s", hueRank, shadeRank)
  plt <- pseq2 %>%
    ps_get() %>%
    #tax_mutate("Phylum: Family" = hierarchicalPalInfo$Taxa, .keep = "none") %>%
    tax_mutate(!!col_nm := hierarchicalPalInfo$Taxa, .keep = "none") %>%
    tax_transform("compositional") %>%
    ##ps_arrange(desc(!!sym(target_taxa_name)), .target = "otu_table") %>% 
    comp_barplot(
      tax_level = col_nm, n_taxa = length(hierarchicalPal),
      sample_order = "asis", counts_warn = FALSE,
      x = "AN_NR",
      tax_order = "asis", 
      palette = hierarchicalPal, bar_width = 0.975
    ) +
    coord_flip() +
    #ggtitle(paste0(my_title)) +
    #theme(legend.text = element_text(family = "mono")) # for text alignment
    facet_wrap(facet, nrow = 1, scales = "fixed") +
    labs(x= "Sample ID", y = "Relative abundance",
         title = my_title,
        subtitle = my_subtitle) +
    scale_y_continuous(expand = expansion(add = c(0, 0.05))) + # axis starts exactly at 0
    theme_bw() + # slightly clearer axes for facets
    theme(panel.spacing.x = unit(6, "mm")) # space for non-overlapping axis numbers
    # theme(axis.text.y = element_blank(), 
    #       axis.ticks.y = element_blank(),
    #       text = element_text(size = 14),
    #       plot.title = element_text(size=16, face="bold"))
  return(plt)
}
### v03
CompositionalPlot_Viz_v03 <- function(PhyloseqObj, 
                                      supper_rank='phylum', 
                                      smaller_rank = "family",
                                      ##target_taxa_name = "Sphingomonadaceae",
                                      supper_rank_list = NULL,
                                      facet = NULL, each_num = 4, 
                                      tax_order_by = sum,
                                      tax_trans = "identity", ## compositional
                                      my_title="Bacterial Composition",
                                      my_subtitle = ""){
  hueRank <- supper_rank
hueRankPlural <- switch (hueRank,
  "phylum" = "phyla",
  "class" = "classes",
  "order" = "orders",
  "family" = "families",
  "genus" = "genera"
)
shadeRank <- smaller_rank
my_order <- supper_rank_list

# Sort phyloseq at lower, and then higher ranks
pseq2 <- PhyloseqObj %>%
  #ps_filter(gender == "male") %>%
  tax_sort(by = tax_order_by, at = shadeRank, na.rm = TRUE, trans = tax_trans) %>%
  tax_sort(by = tax_order_by, at = hueRank, na.rm = TRUE, trans = tax_trans) %>%
  tax_agg(rank = shadeRank)

## sort taxa
tax_tbl <- tax_tibble(pseq2) %>%
  dplyr::arrange(match(.data[[hueRank]], my_order)) %>%
  remove_rownames() %>%
  column_to_rownames(var = "FeatureID")
pseq2 <- pseq2 %>%
  tax_reorder(tax_order = rownames(tax_tbl))

# Specify number of hues and shades desired
nHues <- length(supper_rank_list) # "Other" phyla will be shades of grey
nShades <- each_num # "Other" families will be the lightest shade of each hue

hierarchicalPalInfo <- data.frame(
  hue = as.vector(tt_get(pseq2)[, hueRank]),
  shade = as.vector(tt_get(pseq2)[, shadeRank]),
  counts = taxa_sums(otu_get(pseq2))
)

hierarchicalPalInfo <- hierarchicalPalInfo %>%
  dplyr::mutate(
    hue = forcats::fct_other(
      f = hue, keep = unique(hue)[seq_len(nHues)],
      other_level = paste("Other", hueRankPlural)
    ),
    nChrHue = nchar(as.character(hue)), padHue = max(nChrHue) - nChrHue
  ) %>%
  dplyr::group_by(hue) %>%
  dplyr::mutate(
    shade = forcats::fct_other(
      f = shade, keep = unique(shade)[seq_len(nShades - 1)],
      other_level = "Other"
    )
  ) %>%
  dplyr::mutate(n_shades = length(unique(shade))) %>% 
  dplyr::ungroup() %>%
  dplyr::mutate(
    nChrShade = nchar(as.character(shade)), padShade = max(nChrShade) - nChrShade,
    Taxa = paste0(hue, ": ", strrep(" ", padHue), shade, strrep(" ", padShade))
  )

hierarchicalPalMatrix <- matrix(
data = sapply(
  X = seq(from = 30, to = 75, length.out = nShades),
  FUN = function(l) scales::hue_pal(l = l, h.start = 30)(n = nHues)
  ),
  byrow = TRUE, ncol = nHues
)

hierarchicalPalMatrix <- cbind(hierarchicalPalMatrix, grey.colors(n = nShades))

## remove some of shade if there is not enough taxa
#mask_matrix <- matrix(data = 1, nrow = nrow(hierarchicalPalMatrix), ncol = ncol(hierarchicalPalMatrix))
v <- hierarchicalPalInfo[, c("hue", "n_shades")] %>% unique() %>% pull(n_shades)
hierarchicalPalMatrix[row(hierarchicalPalMatrix) > rep(v, each = nrow(hierarchicalPalMatrix))] <- NA


hierarchicalPal <- hierarchicalPalMatrix %>%
  as.vector() %>%
  na.omit() %>% 
  setNames(unique(hierarchicalPalInfo$Taxa))

col_nm <- sprintf("%s: %s", hueRank, shadeRank)
plt <- pseq2 %>%
  ps_get() %>%
  #tax_mutate("Phylum: Family" = hierarchicalPalInfo$Taxa, .keep = "none") %>%
  tax_mutate(!!col_nm := hierarchicalPalInfo$Taxa, .keep = "none") %>%
  tax_transform("compositional") %>%
  #ps_arrange(desc(!!sym(target_taxa_name)), .target = "otu_table") %>%
  comp_barplot(
    tax_level = col_nm, n_taxa = length(hierarchicalPal),
    #tax_order = "asis",
    sample_order = "asis", counts_warn = FALSE,
    tax_order = "asis",
    palette = hierarchicalPal, bar_width = 0.975
  ) +
  coord_flip() +
  #ggtitle(paste0(my_title)) +
  #theme(legend.text = element_text(family = "mono")) # for text alignment
  facet_wrap(facet, nrow = 1, scales = "free") +
  labs(x = NULL, y = NULL,
       title = my_title,
      subtitle = my_subtitle) +
  theme(axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        text = element_text(size = 14),
        plot.title = element_text(size=16, face="bold"))
## test
plt <- pseq2 %>%
  tax_mutate(!!col_nm := hierarchicalPalInfo$Taxa, .keep = "none") %>%
  ps_arrange(AN_NR) %>%
  ps_mutate(AN_NR = factor(AN_NR, rev(unique(AN_NR)))) %>%
  comp_barplot(
    tax_level = col_nm, n_taxa = length(hierarchicalPal),
    sample_order = "asis", x = "AN_NR",
    tax_order = "asis",
    palette = hierarchicalPal, bar_width = 0.975
  ) +
  facet_wrap(facets = vars(Replica), scales = "fixed") +
  coord_flip() +
  labs( x= "Sample ID", y = "Relative abundance",
        title = my_title,
        subtitle = my_subtitle) +
  scale_y_continuous(expand = expansion(add = c(0, 0.05))) + # axis starts exactly at 0
  theme_bw() + # slightly clearer axes for facets
  theme(panel.spacing.x = unit(6, "mm")) # space for non-overlapping axis numbers
return(plt)
}

## Version 04
CompositionalPlot_Viz_v04 <- function(PhyloseqObj, 
                                      supper_rank='phylum', 
                                      smaller_rank = "family",
                                      ##target_taxa_name = "Sphingomonadaceae",
                                      n_super_rank = 3,
                                      my_facet = NULL, each_num = 4, 
                                      tax_order_by = sum,
                                      tax_trans = "identity", ## compositional
                                      my_title="Bacterial Composition",
                                      my_subtitle = ""){
  hueRank <- supper_rank
  hueRankPlural <- switch (hueRank,
    "phylum" = "phyla",
    "class" = "classes",
    "order" = "orders",
    "family" = "families",
    "genus" = "genera"
  )
  shadeRank <- smaller_rank
  #my_order <- supper_rank_list
  
  # Sort phyloseq at lower, and then higher ranks
  pseq2 <- PhyloseqObj %>%
    #ps_filter(gender == "male") %>%
    tax_sort(by = tax_order_by, at = shadeRank, na.rm = TRUE, trans = tax_trans) %>%
    tax_sort(by = tax_order_by, at = hueRank, na.rm = TRUE, trans = tax_trans) %>%
    tax_agg(rank = shadeRank)
  
  ## sort taxa
  # tax_tbl <- tax_tibble(pseq2) %>%
  #   dplyr::arrange(match(.data[[hueRank]], my_order)) %>%
  #   remove_rownames() %>%
  #   column_to_rownames(var = "FeatureID")
  # pseq2 <- pseq2 %>%
  #   tax_reorder(tax_order = rownames(tax_tbl))
  
  # Specify number of hues and shades desired
  nHues <- n_super_rank ##length(supper_rank_list) # "Other" phyla will be shades of grey
  nShades <- each_num # "Other" families will be the lightest shade of each hue
  
  hierarchicalPalInfo <- data.frame(
    hue = as.vector(tt_get(pseq2)[, hueRank]),
    shade = as.vector(tt_get(pseq2)[, shadeRank]),
    counts = taxa_sums(otu_get(pseq2))
  )
  
  hierarchicalPalInfo <- hierarchicalPalInfo %>%
    dplyr::mutate(
      hue = forcats::fct_other(
        f = hue, keep = unique(hue)[seq_len(nHues)],
        other_level = paste("Other", hueRankPlural)
      ),
      nChrHue = nchar(as.character(hue)), padHue = max(nChrHue) - nChrHue
    ) %>%
    dplyr::group_by(hue) %>%
    dplyr::mutate(
      shade = forcats::fct_other(
        f = shade, keep = unique(shade)[seq_len(nShades - 1)],
        other_level = "Other"
      )
    ) %>%
    dplyr::mutate(n_shades = length(unique(shade))) %>% 
    dplyr::ungroup() %>%
    dplyr::mutate(
      nChrShade = nchar(as.character(shade)), padShade = max(nChrShade) - nChrShade,
      Taxa = paste0(hue, ": ", strrep(" ", padHue), shade, strrep(" ", padShade))
    )
  
  hierarchicalPalMatrix <- matrix(
  data = sapply(
    X = seq(from = 30, to = 75, length.out = nShades),
    FUN = function(l) scales::hue_pal(l = l, h.start = 30)(n = nHues)
    ),
    byrow = TRUE, ncol = nHues
  )
  
  hierarchicalPalMatrix <- cbind(hierarchicalPalMatrix, grey.colors(n = nShades))
  
  ## remove some of shade if there is not enough taxa
  #mask_matrix <- matrix(data = 1, nrow = nrow(hierarchicalPalMatrix), ncol = ncol(hierarchicalPalMatrix))
  v <- hierarchicalPalInfo[, c("hue", "n_shades")] %>% unique() %>% pull(n_shades)
  hierarchicalPalMatrix[row(hierarchicalPalMatrix) > rep(v, each = nrow(hierarchicalPalMatrix))] <- NA
  
  
  hierarchicalPal <- hierarchicalPalMatrix %>%
    as.vector() %>%
    na.omit() %>% 
    setNames(unique(hierarchicalPalInfo$Taxa))
  
  col_nm <- sprintf("%s: %s", hueRank, shadeRank)
  plt <- pseq2 %>%
    ps_get() %>%
    #tax_mutate("Phylum: Family" = hierarchicalPalInfo$Taxa, .keep = "none") %>%
    tax_mutate(!!col_nm := hierarchicalPalInfo$Taxa, .keep = "none") %>%
    tax_transform("compositional") %>%
    #ps_arrange(desc(!!sym(target_taxa_name)), .target = "otu_table") %>%
    comp_barplot(
      tax_level = col_nm, n_taxa = length(hierarchicalPal),
      #tax_order = "asis",
      sample_order = "asis", counts_warn = FALSE,
      tax_order = "asis",
      palette = hierarchicalPal, bar_width = 0.975
    ) +
    coord_flip() +
    #ggtitle(paste0(my_title)) +
    #theme(legend.text = element_text(family = "mono")) # for text alignment
    facet_wrap(my_facet, nrow = 1, scales = "free") +
    labs(x = NULL, y = NULL,
         title = my_title,
        subtitle = my_subtitle) +
    theme(axis.text.y = element_blank(),
          axis.ticks.y = element_blank(),
          text = element_text(size = 14),
          plot.title = element_text(size=16, face="bold"))
  ## test
  plt <- pseq2 %>%
    tax_mutate(!!col_nm := hierarchicalPalInfo$Taxa, .keep = "none") %>%
    ps_arrange(AN_NR) %>%
    ps_mutate(AN_NR = factor(AN_NR, rev(unique(AN_NR)))) %>%
    comp_barplot(
      tax_level = col_nm, n_taxa = length(hierarchicalPal),
      sample_order = "asis", x = "AN_NR",
      tax_order = "asis",
      palette = hierarchicalPal, bar_width = 0.975
    ) +
    facet_wrap(facets = vars(Replica), scales = "fixed") +
    coord_flip() +
    labs( x= "Sample ID", y = "Relative abundance",
          title = my_title,
          subtitle = my_subtitle) +
    scale_y_continuous(expand = expansion(add = c(0, 0.05))) + # axis starts exactly at 0
    theme_bw() + # slightly clearer axes for facets
    theme(panel.spacing.x = unit(6, "mm")) # space for non-overlapping axis numbers
  return(plt)
}
```

**Load original data**

```{r}
#| include: false
## Load data
#source("../../../add_code/Functions.R")
df_additionalInfo <- rprojroot::find_rstudio_root_file() %>% 
  file.path("meta/Mice_meta.xlsx") %>% 
  readxl::read_xlsx()
pseq_raw <- rprojroot::find_rstudio_root_file() %>% 
  file.path("data/Chap3/pseq_Proj5_postFilter_v04.rds") %>% 
  readRDS() %>% 
  ps_filter(ffpe.bulk == "bulk") %>% 
  ps_filter(true.control == "true") %>% 
  append_AN_NR(df_additional = df_additionalInfo) #%>% 
  #WrenchWrapper(grp = "Sex") 
pseq_restrictive <- rprojroot::find_rstudio_root_file() %>% 
  file.path("data/Chap3/pseq_bulk_restrictive.rds") %>% 
  readRDS() %>% 
  append_AN_NR(df_additionalInfo) #%>% 
  #WrenchWrapper(grp = "Sex")
pseq_decontam <- rprojroot::find_rstudio_root_file() %>% 
  file.path("data/Chap3/pseq_bulk_decontam_p0.5.rds") %>% 
  readRDS() %>% 
  append_AN_NR(df_additionalInfo) #%>% 
  #WrenchWrapper(grp = "Sex")
pseq_SCRuB <- rprojroot::find_rstudio_root_file() %>%
  file.path("data/Chap3/pseq_bulk_SCRuB.rds") %>% 
  readRDS() %>% 
  append_AN_NR(df_additionalInfo) #%>% 
  #WrenchWrapper(grp = "Sex")
pseq_Nj <- rprojroot::find_rstudio_root_file() %>%
  file.path("data/Chap3/pseq_bulk_Fisher_v02.rds") %>% 
  readRDS() %>% 
  append_AN_NR(df_additionalInfo) #%>% 
  #WrenchWrapper(grp = "Sex")
```

**Load replica**

```{r}
rep_raw <- rprojroot::find_rstudio_root_file() %>%
  file.path("data/Chap3_Addition/pseq_origin_v1.0.rds") %>% 
  readRDS() %>% 
  ps_filter(ffpe.bulk == "bulk") %>% 
  append_AN_NR(df_additional = df_additionalInfo)
rep_restrictive <- rprojroot::find_rstudio_root_file() %>%
  file.path("data/Chap3_Addition/pseq_restrictive.rds") %>% 
  readRDS() %>% 
  append_AN_NR(df_additional = df_additionalInfo)
rep_decontam <- rprojroot::find_rstudio_root_file() %>%
  file.path("data/Chap3_Addition/pseq_decontam.rds") %>% 
  readRDS() %>% 
  append_AN_NR(df_additional = df_additionalInfo)
rep_SCRuB <- rprojroot::find_rstudio_root_file() %>%
  file.path("data/Chap3_Addition/pseq_SCRuB.rds") %>% 
  readRDS() %>% 
  append_AN_NR(df_additional = df_additionalInfo)
rep_Nj <- rprojroot::find_rstudio_root_file() %>% 
  file.path("data/Chap3_Addition/pseq_Nejman.rds") %>% 
  readRDS() %>% 
  append_AN_NR(df_additional = df_additionalInfo)
## rename taxa
taxa_names(rep_raw) <- gsub(pattern = " ", replacement = "_", x = taxa_names(rep_raw))
taxa_names(rep_restrictive) <- gsub(pattern = " ", replacement = "_", x = taxa_names(rep_restrictive))
taxa_names(rep_decontam) <- gsub(pattern = " ", replacement = "_", x = taxa_names(rep_decontam))
taxa_names(rep_SCRuB) <- gsub(pattern = " ", replacement = "_", x = taxa_names(rep_SCRuB))
taxa_names(rep_Nj) <- gsub(pattern = " ", replacement = "_", x = taxa_names(rep_Nj))
```

Retain only sample with pair

```{r}
IDs <- meta(rep_raw)[["AN_NR"]]
pseq_raw <- pseq_raw %>% ps_filter(AN_NR %in% IDs)
pseq_restrictive <- pseq_restrictive %>% ps_filter(AN_NR %in% IDs)
pseq_decontam <- pseq_decontam %>% ps_filter(AN_NR %in% IDs)
pseq_SCRuB <- pseq_SCRuB %>% ps_filter(AN_NR %in% IDs)
pseq_Nj <- pseq_Nj %>% ps_filter(AN_NR %in% IDs)
```

# Project Structure through Mind-Map

```{mermaid}
flowchart TD
  %%A[Hard edge] --> B(Round edge)
  %%A --> F(Others)
  %%B --> C{Decision}
  %%C --> D[Result one]
  %%C --> E[Result two]
  
  S(Replica Analysis) --> B(Properties of Replica)
  S --> C(Overlap)
  C --> C1(UpsetPlot-Phylum)
  C --> C2(UpsetPlot-Class)
  S --> D(Assessment)
  D --> D1(1.Intra-Sample Stability)
  D --> D2(2.PERANOVA)
  
```

# Replica Properties

## Alpha

Diversity between

## Beta

# Assessment

Using replica as additional dataset for assessment of decontamination approaches.

## 1. Intra-samples Stability

-   **Assumption**: after removing contaminants, bacterial profile of a sample should be stable, regardless of sequencing year or technician.
-   **Method**: using appropriate distance function to measure the (dis)similarity of the sample sample w.r.t 2 technical replicas. Afterwards, applying paired t-test or Wilcoxon Signed-Rank Test, LMM, or constrained permutation test.

### 1.1 Bray-curtis distance with compositional normalization

```{r}
## Write a wrapper

process_replica <- function(
    ps1, ## original sample
    ps2, ## replica 
    normalize = "compositional", ## compositional - bray | clr - euclidean
    distance = "bray",
    col_name = "raw"){
  ## add replica info and change names
  ps1 <- ps1 %>% 
    ps_mutate(Replica = "R1") %>% 
    ps_mutate(NewName = sprintf("%s_%s", AN_NR, Replica))
  sample_names(ps1) <- meta(ps1)[["NewName"]]
  
  ps2 <- ps2 %>% 
    ps_mutate(Replica = "R2") %>% 
    ps_mutate(NewName = sprintf("%s_%s", AN_NR, Replica))
  sample_names(ps2) <- meta(ps2)[["NewName"]]
  
  ps_merged <- merge_phyloseq(ps1, ps2)
  if(normalize == "rarefaction"){
    ps_merged <- ps_merged %>% rarefy_even_depth()
  }else if(normalize == "Wrench"){
    ps_merged <- ps_merged %>% WrenchWrapper(grp = "Sex", roundUp = FALSE)
  } else if(normalize %in%  c("clr", "compositional")){
    ps_merged <- ps_merged %>% microbiome::transform(transform = normalize)
  }
  
  # merge_phyloseq(ps1, ps2) %>% 
  #   microbiome::transform(transform = normalize) %>% 
  dis_mx <- NULL
  if(distance == "jaccard"){
    dis_mx <- ps_merged %>% 
      phyloseq::distance(method = distance, binary = TRUE)
  } else{
    dis_mx <- ps_merged %>% 
      phyloseq::distance(method = distance)
  }
  dis_mx <- dis_mx %>% 
    # ps_merged %>% 
    # phyloseq::distance(method = distance) %>% 
    as.matrix() %>% 
    as.data.frame() %>% 
    dplyr::select(contains("R2")) %>% 
    rownames_to_column(var = "rowname") %>% 
    filter(grepl("R1", rowname)) %>% 
    arrange(rowname) %>% 
    column_to_rownames("rowname") %>% 
    select(sort(names(.)))
  col <- tibble(AN_NR = sapply(rownames(dis_mx), FUN = function(x){strsplit(x, split = "_")[[1]][1]}), !!sym(col_name) := diag(as.matrix(dis_mx)))
  return(col)
}
```

Create wide-format table

```{r}
df <- process_replica(pseq_raw, rep_raw, col_name = "Raw") %>% 
  merge(., process_replica(pseq_restrictive, rep_restrictive, col_name = "Restrictive"), by = "AN_NR") %>%
  merge(., process_replica(pseq_decontam, rep_decontam, col_name = "Decontam"), by="AN_NR") %>% 
  merge(., process_replica(pseq_SCRuB, rep_SCRuB, col_name = "SCRuB"), by="AN_NR") %>% 
  merge(., process_replica(pseq_Nj, rep_Nj, col_name = "Nj"), by="AN_NR")
df_longer <- df %>% 
  pivot_longer(cols = -AN_NR, names_to = "Methods", values_to = "Val")
#df_longer_1 <- df_longer %>% filter(Methods %in% c("Raw", "Nj"))
print(df)
```

Wilcox-test on Distance

```{r}
df_longer$Methods <- factor(df_longer$Methods, levels = c("Raw", "Restrictive", "Decontam", "SCRuB", "Nj"))
AlphaPlot_Violin_Wilcox(df_longer, "AN_NR", "Methods", "Val", y_label = "bray distance", subtitle = "The lower the better", comparisons = list(c("Raw", "Restrictive"), c("Raw", "Decontam"), c("Raw", "SCRuB"), c("Raw", "Nj")), alternative = "greater")
```

Negative Log Distance (only for a bit nicer illustration)

```{r}
df_longer %>% 
  mutate(Val_NegLog = -log(Val)) %>% 
AlphaPlot_Violin_Wilcox("AN_NR", "Methods", "Val_NegLog", y_label = "Neg Log b-ray distance", subtitle = "The higher the better", comparisons = list(c("Raw", "Restrictive"), c("Raw", "Decontam"), c("Raw", "SCRuB"), c("Raw", "Nj")), alternative = "less")
```

**Remarks**: Decontam and Nj seems to have smaller distance among replicates.

#### For each sample, plot beta plot

```{r}
# edit metadata
# pseq_raw <- pseq_raw %>% 
#   ps_mutate(Method = "Raw", Replica = "R1") %>% 
#   ps_mutate(NewName = sprintf("%s_%s_%s", AN_NR, Method, Replica))
# sample_names(pseq_raw) <- meta(pseq_raw)[["NewName"]]
# pseq_raw <- pseq_raw %>% ps_select(-NewName)
# 
# lapply()

lst_ps <- list(Raw = pseq_raw, Restrictive = pseq_restrictive, Decontam = pseq_decontam, SCRuB = pseq_SCRuB, Nj = pseq_Nj)
lst_rep <- list(Raw = rep_raw, Restrictive = rep_restrictive, Decontam = rep_decontam, SCRuB = rep_SCRuB, Nj = rep_Nj)

lst_ps <- lapply(seq_along(lst_ps), function(i){
  nm <- names(lst_ps[i])
  res <- lst_ps[[i]] %>% 
    ps_mutate(Method = nm, Replica = "R1") %>% 
    ps_mutate(NewName = sprintf("%s_%s_%s", AN_NR, Method, Replica))
  sample_names(res) <- meta(res)[["NewName"]]
  res <- res %>% ps_select(-NewName)
  return(res)
}) %>% unlist()
names(lst_ps) <- c("Raw", "Restrictive", "Decontam", "SCRuB", "Nj")
lst_rep <- lapply(seq_along(lst_rep), function(i){
  nm <- names(lst_rep[i])
  res <- lst_rep[[i]] %>% 
    ps_mutate(Method = nm, Replica = "R2") %>% 
    ps_mutate(NewName = sprintf("%s_%s_%s", AN_NR, Method, Replica))
  sample_names(res) <- meta(res)[["NewName"]]
  res <- res %>% ps_select(-NewName)
  return(res)
}) %>% unlist()
names(lst_rep) <- c("Raw", "Restrictive", "Decontam", "SCRuB", "Nj")
#id <- "AN1023"

# ps_1023 <- merge_phyloseq(lst_ps$Raw, lst_ps$Restrictive, lst_ps$Decontam, lst_ps$SCRuB, lst_ps$Nj,
#                           lst_rep$Raw, lst_rep$Restrictive, lst_rep$Decontam, lst_rep$SCRuB, lst_rep$Nj)
# ps_1023 <- ps_1023 %>% prune_samples(meta(.)[["AN_NR"]] == "AN1023", .)
# ord <- ps_1023 %>% microbiome::transform(transform = "identity") %>% 
#   ordinate(method = "PCoA", distance = "jaccard")
# 
# plot_ordination(ps_1023, ord, color = "Method", shape = "Replica") +
#   geom_point(size = 3) +
#   theme_bw() +
#   labs(title = "Beta diversity (Brayâ€“Curtis, PCoA)")


samplewise_plot <- function(pseq_merge, Sample_ID, normalized = "identity", dist_metric = "bray"){
  ## normalized: compositional, rarefaction, Wrench
  ## dist_metric: bray, unifrac, 
  pseq_one <- pseq_merge %>% 
    prune_samples(meta(.)[["AN_NR"]] == Sample_ID, .) %>% 
    prune_taxa(taxa_sums(.) >0, .)
  if(normalized == "rarefaction"){
    pseq_one <- pseq_one %>% rarefy_even_depth()
  }else if(normalized == "Wrench"){
    pseq_one <- pseq_one %>% WrenchWrapper(grp = "Sex", roundUp = FALSE)
  } else if(normalized %in%  c("clr", "compositional", "identity")){
    pseq_one <- pseq_one %>% microbiome::transform(transform = normalized)
  }
  beta_dis = NULL
  if(dist_metric %in%  c("bray", "jaccard", "unifrac", "jsd", "euclidean")){
    beta_dis <- pseq_one %>% phyloseq::distance(method = dist_metric)
  }
  # print(pseq_one)
  # print(pseq_one %>% meta())
  # print(beta_dis)
  ord <- phyloseq::ordinate(pseq_one, method = "PCoA", distance = beta_dis)
  # print(ord)
  plt <- plot_ordination(pseq_one, ord, color = "Method", shape = "Replica") +
  geom_point(size = 4, alpha = 0.8) +
  theme_bw() +
  ##stat_ellipse(aes(group = Condition), linetype = 2) + # Add confidence ellipses
  labs(title = sprintf("%s: %s Distance - %s transform", Sample_ID, dist_metric, normalized),
       subtitle = sprintf("Colored by Methods, Shaped by Replica"))
  return(plt)
} 
```

Plot

```{r}
pseq_merge <- merge_phyloseq(lst_ps$Raw, lst_ps$Restrictive, lst_ps$Decontam, lst_ps$SCRuB, lst_ps$Nj,
                             lst_rep$Raw, lst_rep$Restrictive, lst_rep$Decontam, lst_rep$SCRuB, lst_rep$Nj)
IDs <- meta(pseq_raw)[["AN_NR"]]
plt <- sapply(IDs, FUN = function(x){samplewise_plot(pseq_merge, x, normalized = "compositional", dist_metric = "bray")}) 
require(patchwork)
plt[1]
```

```{r}
plt[2]
```

```{r}
plt[3]
```

```{r}
plt[4]
```

```{r}
plt[5]
```

```{r}
plt[6]
```

```{r}
plt[7]
```

```{r}
plt[8]
```

```{r}
plt[9]
```

```{r}
plt[10]
```

### 1.2 Bray-curtis distance with rarefaction

Remove AN986 due to low read count.

```{r}
df <- process_replica(pseq_raw %>% ps_filter(AN_NR != "AN986"), rep_raw %>%  ps_filter(AN_NR != "AN986"), normalize = "rarefaction", distance = "bray", col_name = "Raw") %>% 
  left_join(., process_replica(pseq_restrictive %>% ps_filter(AN_NR != "AN986"), rep_restrictive %>% ps_filter(AN_NR != "AN986"), normalize = "rarefaction", distance = "bray", col_name = "Restrictive"), by = "AN_NR") %>%
  left_join(., process_replica(pseq_decontam %>% ps_filter(AN_NR != "AN986"), rep_decontam %>% ps_filter(AN_NR != "AN986"), normalize = "rarefaction", distance = "bray", col_name = "Decontam"), by="AN_NR") %>% 
  left_join(., process_replica(pseq_SCRuB %>% ps_filter(AN_NR != "AN986"), rep_SCRuB %>% ps_filter(AN_NR != "AN986"), normalize = "rarefaction", distance = "bray", col_name = "SCRuB"), by="AN_NR") %>% 
  left_join(., process_replica(pseq_Nj %>% ps_filter(AN_NR != "AN986"), rep_Nj %>% ps_filter(AN_NR != "AN986"), normalize = "rarefaction", distance = "bray", col_name = "Nj"), by="AN_NR")
df_longer <- df %>% 
  pivot_longer(cols = -AN_NR, names_to = "Methods", values_to = "Val")
#df_longer_1 <- df_longer %>% filter(Methods %in% c("Raw", "Nj"))
print(df)
```

Wilcox-test

```{r}
AlphaPlot_Violin_Wilcox(df_longer, "AN_NR", "Methods", "Val", y_label = "b-ray distance", subtitle = "The lower the better", comparisons = list(c("Raw", "Restrictive"), c("Raw", "Decontam"), c("Raw", "SCRuB"), c("Raw", "Nj")), alternative = "greater")
```

```{r}
plt <- sapply(setdiff(IDs, "AN986"), FUN = function(x){samplewise_plot(pseq_merge, x, normalized = "rarefaction", dist_metric = "bray")}) 
```

### 1.2+ Bray-curtis distance with Wrench normalization

```{r}
dist_metric <- "bray"
trans <-"Wrench"  #"rarefaction"
df <- process_replica(pseq_raw, rep_raw, normalize = trans, distance = dist_metric, col_name = "Raw") %>% 
  left_join(., process_replica(pseq_restrictive, rep_restrictive, normalize = trans, distance = dist_metric, col_name = "Restrictive"), by = "AN_NR") %>%
  left_join(., process_replica(pseq_decontam, rep_decontam, normalize = trans, distance = dist_metric, col_name = "Decontam"), by="AN_NR") %>% 
  left_join(., process_replica(pseq_SCRuB, rep_SCRuB, normalize = trans, distance = dist_metric, col_name = "SCRuB"), by="AN_NR") %>% 
  left_join(., process_replica(pseq_Nj, rep_Nj, normalize = trans, distance = dist_metric, col_name = "Nj"), by="AN_NR")
df_longer <- df %>% 
  pivot_longer(cols = -AN_NR, names_to = "Methods", values_to = "Val")
#df_longer_1 <- df_longer %>% filter(Methods %in% c("Raw", "Nj"))
print(df)
```

Wilcox test

```{r}
df_longer$Methods <- factor(df_longer$Methods, levels = c("Raw", "Restrictive", "Decontam", "SCRuB", "Nj"))
res <- wilcox_test(data = df_longer, formula = Val ~ Methods, paired = TRUE, comparisons = list(c("Raw", "Restrictive"), c("Raw", "Decontam"), c("Raw", "SCRuB"), c("Raw", "Nj")), alternative = "greater")
print(res)
```

### 1.3 Jarcard distance with rarefaction

Remove AN986 due to low read count.

```{r}
dist_metric <- "jaccard"
trans <-"identity"  #"rarefaction"
df <- process_replica(pseq_raw %>% ps_filter(AN_NR != "AN986"), rep_raw %>%  ps_filter(AN_NR != "AN986"), normalize = trans, distance = dist_metric, col_name = "Raw") %>% 
  left_join(., process_replica(pseq_restrictive %>% ps_filter(AN_NR != "AN986"), rep_restrictive %>% ps_filter(AN_NR != "AN986"), normalize = trans, distance = dist_metric, col_name = "Restrictive"), by = "AN_NR") %>%
  left_join(., process_replica(pseq_decontam %>% ps_filter(AN_NR != "AN986"), rep_decontam %>% ps_filter(AN_NR != "AN986"), normalize = trans, distance = dist_metric, col_name = "Decontam"), by="AN_NR") %>% 
  left_join(., process_replica(pseq_SCRuB %>% ps_filter(AN_NR != "AN986"), rep_SCRuB %>% ps_filter(AN_NR != "AN986"), normalize = trans, distance = dist_metric, col_name = "SCRuB"), by="AN_NR") %>% 
  left_join(., process_replica(pseq_Nj %>% ps_filter(AN_NR != "AN986"), rep_Nj %>% ps_filter(AN_NR != "AN986"), normalize = trans, distance = dist_metric, col_name = "Nj"), by="AN_NR")
df_longer <- df %>% 
  pivot_longer(cols = -AN_NR, names_to = "Methods", values_to = "Val")
#df_longer_1 <- df_longer %>% filter(Methods %in% c("Raw", "Nj"))
print(df)
```

Wilcox

```{r}
df_longer$Methods <- factor(df_longer$Methods, levels = c("Raw", "Restrictive", "Decontam", "SCRuB", "Nj"))
AlphaPlot_Violin_Wilcox(df_longer, "AN_NR", "Methods", "Val", y_label = "Jarcard distance", subtitle = "The lower the better", comparisons = list(c("Raw", "Restrictive"), c("Raw", "Decontam"), c("Raw", "SCRuB"), c("Raw", "Nj")), alternative = "greater")
```

For a nicer view,

```{r}
df_longer %>% 
  mutate(Val_NegLog = -1*log(Val)) %>% 
  AlphaPlot_Violin_Wilcox("AN_NR", "Methods", "Val_NegLog", y_label = "Jarcard distance", subtitle = "The higher the better", comparisons = list(c("Raw", "Restrictive"), c("Raw", "Decontam"), c("Raw", "SCRuB"), c("Raw", "Nj")), alternative = "less")
```

### 1.3+ Jarcard distance with Wrench normalization

```{r}
dist_metric <- "jaccard"
trans <-"Wrench"  #"rarefaction"
df <- process_replica(pseq_raw, rep_raw, normalize = trans, distance = dist_metric, col_name = "Raw") %>% 
  left_join(., process_replica(pseq_restrictive, rep_restrictive, normalize = trans, distance = dist_metric, col_name = "Restrictive"), by = "AN_NR") %>%
  left_join(., process_replica(pseq_decontam, rep_decontam, normalize = trans, distance = dist_metric, col_name = "Decontam"), by="AN_NR") %>% 
  left_join(., process_replica(pseq_SCRuB, rep_SCRuB, normalize = trans, distance = dist_metric, col_name = "SCRuB"), by="AN_NR") %>% 
  left_join(., process_replica(pseq_Nj, rep_Nj, normalize = trans, distance = dist_metric, col_name = "Nj"), by="AN_NR")
df_longer <- df %>% 
  pivot_longer(cols = -AN_NR, names_to = "Methods", values_to = "Val")
#df_longer_1 <- df_longer %>% filter(Methods %in% c("Raw", "Nj"))
print(df)
```

Wilcox

```{r}
df_longer$Methods <- factor(df_longer$Methods, levels = c("Raw", "Restrictive", "Decontam", "SCRuB", "Nj"))
AlphaPlot_Violin_Wilcox(df_longer, "AN_NR", "Methods", "Val", y_label = "Jarcard distance", subtitle = "The lower the better", comparisons = list(c("Raw", "Restrictive"), c("Raw", "Decontam"), c("Raw", "SCRuB"), c("Raw", "Nj")), alternative = "greater")
```

### 1.4 **Aitchison - CLR transform with eucledian distance**

```{r}
dist_metric <- "euclidean"
trans <-"clr"  #"rarefaction"
df <- process_replica(pseq_raw, rep_raw, normalize = trans, distance = dist_metric, col_name = "Raw") %>% 
  left_join(., process_replica(pseq_restrictive, rep_restrictive, normalize = trans, distance = dist_metric, col_name = "Restrictive"), by = "AN_NR") %>%
  left_join(., process_replica(pseq_decontam, rep_decontam, normalize = trans, distance = dist_metric, col_name = "Decontam"), by="AN_NR") %>% 
  left_join(., process_replica(pseq_SCRuB, rep_SCRuB, normalize = trans, distance = dist_metric, col_name = "SCRuB"), by="AN_NR") %>% 
  left_join(., process_replica(pseq_Nj, rep_Nj, normalize = trans, distance = dist_metric, col_name = "Nj"), by="AN_NR")
df_longer <- df %>% 
  pivot_longer(cols = -AN_NR, names_to = "Methods", values_to = "Val")
#df_longer_1 <- df_longer %>% filter(Methods %in% c("Raw", "Nj"))
print(df)
```

Wilcox

```{r}
df_longer$Methods <- factor(df_longer$Methods, levels = c("Raw", "Restrictive", "Decontam", "SCRuB", "Nj"))
AlphaPlot_Violin_Wilcox(df_longer, "AN_NR", "Methods", "Val", y_label = "Aitchison distance", subtitle = "The lower the better", alternative = "greater")
```

Plot for each sample

```{r}
plt <- sapply(IDs, FUN = function(x){samplewise_plot(pseq_merge, x, normalized = "clr", dist_metric = "euclidean")}) 
```

```{r}
plt[1]
```

```{r}
plt[2]
```

```{r}
plt[3]
```

```{r}
plt[4]
```

```{r}
plt[5]
```

```{r}
plt[6]
```

```{r}
plt[7]
```

```{r}
plt[8]
```

```{r}
plt[9]
```

```{r}
plt[10]
```

**Remarks**: all decontamination methods seem to improve the data. Among them, Nj outperformed others.

## 2. PERANOVA based Approach

Linear Mixed Model: distance \~ AN_NR + Reaplica

Assumption: With high quality data, the different among samples should be explain by bacterial profile of samples, instead of replica.

<!-- Each Method, calculate distance and adonis2 using dis ~ AN_NR + batch and compare R2. -->

```{r}
process_pernova <- function(ps1, ps2, transform = "compositional", dist_metric = "bray"){
  ps1 <- ps1 %>% 
    ps_mutate(Replica = "R1") %>% 
    ps_mutate(NewName = sprintf("%s_%s", AN_NR, Replica))
  sample_names(ps1) <- meta(ps1)[["NewName"]]
    
  ps2 <- ps2 %>% 
    ps_mutate(Replica = "R2") %>% 
    ps_mutate(NewName = sprintf("%s_%s", AN_NR, Replica))
  sample_names(ps2) <- meta(ps2)[["NewName"]]
  
  ps <- merge_phyloseq(ps1, ps2)
  #print(meta(ps))
  dis_mx <- ps %>% 
    microbiome::transform(transform = transform) %>% 
    phyloseq::distance(method = dist_metric)
  
  res <- vegan::adonis2(formula = dis_mx ~ AN_NR + Replica, data = meta(ps), by = "margin", permutations = 99999)
  return(res)
}
```

Compare among different approaches

```{r}
df_res <- data.frame(Method = character(0), AN_NR = double(0), Rep = double(0))
df_res[nrow(df_res) +1, ] <- c("Raw",process_pernova(pseq_raw, rep_raw, transform = "clr", dist_metric = "euclidean")$R2[1:2] %>% unlist())
df_res[nrow(df_res) +1, ] <- c("Restrictive",process_pernova(pseq_restrictive, rep_restrictive, transform = "clr", dist_metric = "euclidean")$R2[1:2] %>% unlist())
df_res[nrow(df_res) +1, ] <- c("Decontam",process_pernova(pseq_decontam, rep_decontam, transform = "clr", dist_metric = "euclidean")$R2[1:2] %>% unlist())
df_res[nrow(df_res) +1, ] <- c("SCRuB",process_pernova(pseq_SCRuB, rep_SCRuB, transform = "clr", dist_metric = "euclidean")$R2[1:2] %>% unlist())
df_res[nrow(df_res) +1, ] <- c("Nj",process_pernova(pseq_Nj, rep_Nj, transform = "clr", dist_metric = "euclidean")$R2[1:2] %>% unlist())
print(df_res)
```

Remarks: SCRuB outperforms the other

## 3. Overlap

Investigate the microbial profile of 2 technical replica

Facet by Replica

```{r}
## create df_R1
df_R1 <- data.frame(OTU = taxa_names(pseq_raw), Raw = 1) %>% 
  left_join(., data.frame(OTU = taxa_names(pseq_restrictive), Restrictive = 1), by = "OTU") %>% 
  left_join(., data.frame(OTU = taxa_names(pseq_decontam), Decontam = 1), by = "OTU") %>% 
  left_join(., data.frame(OTU = taxa_names(pseq_SCRuB), SCRuB = 1), by = "OTU") %>% 
  left_join(., data.frame(OTU = taxa_names(pseq_Nj), Nj = 1), by = "OTU") %>% 
  select(-Raw) %>% 
  dplyr::mutate_if(is.numeric, coalesce, 0)
df_R1_tax <- tax_tibble(pseq_raw)
df_R1 <- df_R1 %>% 
  left_join(., df_R1_tax, by = c("OTU" = "FeatureID"))

## create df_R2
df_R2 <- data.frame(OTU = taxa_names(rep_raw), Raw = 1) %>% 
  left_join(., data.frame(OTU = taxa_names(rep_restrictive), Restrictive = 1), by = "OTU") %>% 
  left_join(., data.frame(OTU = taxa_names(rep_decontam), Decontam = 1), by = "OTU") %>% 
  left_join(., data.frame(OTU = taxa_names(rep_SCRuB), SCRuB = 1), by = "OTU") %>% 
  left_join(., data.frame(OTU = taxa_names(rep_Nj), Nj = 1), by = "OTU") %>% 
  select(-Raw) %>% 
  dplyr::mutate_if(is.numeric, coalesce, 0)
df_R2_tax <- tax_tibble(rep_raw)
df_R2 <- df_R2 %>% 
  left_join(., df_R2_tax, by = c("OTU" = "FeatureID"))

  #dplyr::mutate_if(is.numeric, coalesce, 0)
```

Phylum

```{r}
#| fig-width: 14
#| fig-height: 10
#| fig-lightbox: true
require(patchwork)
manual_fill = c('Actinomycetota'=Kolors[1], 'Bacillota'=Kolors[2], 'Bacteroidota'= Kolors[3], 'Campylobacterota'=Kolors[4], 'Cyanobacteriota'=Kolors[5], 'Pseudomonadota'=Kolors[6], 'Thermodesulfobacteriota'=Kolors[7], 'Other'=Kolors[8])
df_R1 <- df_R1 %>% mutate(Phylum = if_else(phylum %in% names(manual_fill), phylum, "Other"))
df_R2 <- df_R2 %>% mutate(Phylum = if_else(phylum %in% names(manual_fill), phylum, "Other"))

Medthods <- c("Restrictive", "Decontam", "SCRuB", "Nj")
annotations = list(
    'Phylum' = list(
      aes = aes(x=intersection, fill=Phylum),
      geom = list(
        geom_bar(stat='count', position='fill', na.rm=TRUE),
        # geom_text(
        #   aes(label=ifelse(phylum == 'Pseudomonadota', 'Pseu.', NA)),
        #   stat='count',
        #   position=position_fill(vjust = .5),
        #   na.rm=TRUE
        # ),
        # scale_color_manual(values=c('show'='black', 'hide'='transparent'), guide='none'),
        scale_fill_manual(values = manual_fill)
        
      )
    )
)
set.seed(0)    # for replicable example only

u1 <- upset(df_R1, Medthods, annotations =  annotations, name='R1', width_ratio=0.1)
u2 <- upset(df_R2, Medthods, annotations =  annotations, name='R2', width_ratio=0.1)
(u1 | u2) + plot_layout(guides='collect')
```

Class

```{r}
#| fig-width: 14
#| fig-height: 8
#| fig-lightbox: true
#set_size(16, 5)
manual_fill_class <- c("Alphaproteobacteria"=Kolors[1], "Bacilli"=Kolors[2], "Clostridia"=Kolors[3], "Gammaproteobacteria"=Kolors[4], "Bacteroidia"=Kolors[5], "Betaproteobacteria"=Kolors[6], "Actinomycetes"=Kolors[7], "Flavobacteriia"=Kolors[8], "Negativicutes"=Kolors[9], "Cyanophyceae"=Kolors[10], "Other"=Kolors[11])
df_R1 <- df_R1 %>% mutate(Class = if_else(class %in% names(manual_fill_class), class, "Other"))
df_R2 <- df_R2 %>% mutate(Class = if_else(class %in% names(manual_fill_class), class, "Other"))

annotations_class = list(
    'Class' = list(
      aes = aes(x=intersection, fill=Class),
      geom = list(
        geom_bar(stat='count', position='fill', na.rm=TRUE),
        # geom_text(
        #   aes(label=ifelse(phylum == 'Pseudomonadota', 'Pseu.', NA)),
        #   stat='count',
        #   position=position_fill(vjust = .5),
        #   na.rm=TRUE
        # ),
        # scale_color_manual(values=c('show'='black', 'hide'='transparent'), guide='none'),
        scale_fill_manual(values = manual_fill_class)
        
      )
    )
)
set.seed(0)    # for replicable example only

u1 <- upset(df_R1, Medthods, annotations =  annotations_class, name='R1', width_ratio=0.1)
u2 <- upset(df_R2, Medthods, annotations =  annotations_class, name='R2', width_ratio=0.1)

(u1 | u2) + plot_layout(guides='collect')
```

### 3.1 Investigate microbiome in overlap

-   Facet wrap by Replica

-   Phylum - family clades

-   sorted by a taxa (optional)

Plan:

Taxa order by either sum or prev. If Taxa order by sum, taxa transformation could be compositional or identity.

compbar plots for:

1.  Nj decontamination
2.  Overlap of decontam, SCRuB, and Nj. We obmitted the restrictive because it indiscriminately remove any taxa in NCT, which could potentially lead to remove true positive taxa.
3.  side by side, with and without decontamination.

#### 3.1.1 Taxa order : sum; taxa transformation: identity

##### 3.1.1.1 Nj method

Replica 1 and 2 after Nj decontamination

```{r}
#| fig-width: 10
#| fig-height: 7
#| fig-lightbox: true
ps_merged <- merge_phyloseq(
  pseq_Nj %>% ps_mutate(Replica = "R1", Method = "Nj") %>% ps_mutate(Group = sprintf("%s_%s", Method, Replica)) %>% 
    ps_mutate(NewID = sprintf("%s_%s", Group, AN_NR)) %>% ps_arrange(AN_NR),
  rep_Nj %>% ps_mutate(Replica = "R2", Method = "Nj") %>% ps_mutate(Group = sprintf("%s_%s", Method, Replica)) %>% 
    ps_mutate(NewID = sprintf("%s_%s", Group, AN_NR)) %>% ps_arrange(AN_NR)
)
sample_names(ps_merged) <- meta(ps_merged)[["NewID"]]
plt <- ps_merged %>% 
  CompositionalPlot_Viz_v04(supper_rank = "phylum", smaller_rank = "family", n_super_rank = 3, my_facet = "Replica", each_num = 4, tax_order_by = sum, tax_trans = "identity", my_subtitle = "NJ decontamination")
print(plt)
```

class - genus

```{r}
#| fig-width: 10
#| fig-height: 7
#| fig-lightbox: true
# ps_merged <- merge_phyloseq(
#   pseq_Nj %>% ps_mutate(Replica = "R1") %>% ps_arrange(AN_NR),
#   rep_Nj %>% ps_mutate(Replica = "R2") %>% ps_arrange(AN_NR)
# )
plt <- ps_merged %>% 
  CompositionalPlot_Viz_v04(supper_rank = "class", smaller_rank = "genus", n_super_rank = 3, my_facet = "Replica", each_num = 4, tax_order_by = sum, tax_trans = "identity", my_subtitle = "NJ decontamination")
print(plt)
```

With and without decontamination

Because the number of reads are significantly different, we normalized each patch seperately

```{r}
#| fig-width: 14
#| fig-height: 7
#| fig-lightbox: true
ps_raw_merged <- merge_phyloseq(
  pseq_raw %>% ps_mutate(Replica = "R1", Method = "Raw") %>% ps_mutate(Group = sprintf("%s_%s", Method, Replica)) %>% 
    ps_mutate(NewID = sprintf("%s_%s", Group, AN_NR)) %>% ps_arrange(AN_NR),
  rep_raw %>% ps_mutate(Replica = "R2", Method = "Raw") %>% ps_mutate(Group = sprintf("%s_%s", Method, Replica)) %>% 
    ps_mutate(NewID = sprintf("%s_%s", Group, AN_NR)) %>% ps_arrange(AN_NR)
) %>% 
  microbiome::transform(transform = "compositional")
sample_names(ps_raw_merged) <- meta(ps_raw_merged)[["NewID"]]

ps_all_merged <- merge_phyloseq(
  ps_merged %>% microbiome::transform(transform = "compositional"),
  ps_raw_merged
)
sample_data(ps_all_merged)[["Group"]] <- factor(sample_data(ps_all_merged)[["Group"]], levels = c("Raw_R1", "Nj_R1", "Raw_R2", "Nj_R2"))
ps_all_merged %>% 
  CompositionalPlot_Viz_v04(supper_rank = "phylum", smaller_rank = "family", n_super_rank = 4, my_facet = "Group", each_num = 4, tax_order_by = sum, tax_trans = "identity", my_title = "Compositional Barplot", my_subtitle = "Raw vs Nj")
```

##### 3.1.1.2 Overlap of 3 methods

#### 3.1.2  Taxa order : sum; taxa transformation: compositional

##### 3.1.2.1 Nj method

##### 3.1.2.2 Overlap of 3 methods

#### 3.1.3 Taxa order by prevalence

##### 3.1.3.1 Nj method

##### 3.1.3.2 Overlap of 3 methods

---------------------------------------------------------------

Only phyloseq NJ

```{r}
#| fig-width: 10
#| fig-height: 7
#| fig-lightbox: true
## merge phyloseq
ps_NJ_merged <- merge_phyloseq(
  pseq_Nj %>% ps_mutate(Replica = "R1") %>% ps_arrange(AN_NR),
  rep_Nj %>% ps_mutate(Replica = "R2") %>% ps_arrange(AN_NR)
)
##select_name <- "Lactobacillaceae" ## name in family rank
ps_NJ_merged %>% 
  rarefy_even_depth(sample.size = 7310) %>% 
  #transform_sample_counts(fun = function(x){x/sum(x)}) %>% 
  #CompositionalPlot_Viz_v03(supper_rank = "phylum", smaller_rank = "family", supper_rank_list = c("Bacillota", "Bacteroidota", "Pseudomonadota"), facet = "Replica", each_num = 4, tax_order_by = sum, tax_trans = "identity", my_subtitle = "NJ decontamination")
  CompositionalPlot_Viz_v04(supper_rank = "phylum", smaller_rank = "family", n_super_rank = 3, facet = "Replica", each_num = 4, tax_order_by = sum, tax_trans = "identity", my_subtitle = "NJ decontamination")
```

Raw - without decontamination

```{r}
#| fig-width: 10
#| fig-height: 7
#| fig-lightbox: true
## merge phyloseq
ps_raw_merged <- merge_phyloseq(
  pseq_raw %>% ps_mutate(Replica = "R1") %>% ps_arrange(AN_NR),
  rep_raw %>% ps_mutate(Replica = "R2") %>% ps_arrange(AN_NR)
)
##select_name <- "Lactobacillaceae" ## name in family rank
ps_raw_merged %>% 
  rarefy_even_depth() %>% 
  CompositionalPlot_Viz_v03(supper_rank = "phylum", smaller_rank = "family", supper_rank_list = c("Bacillota", "Bacteroidota", "Pseudomonadota"), facet = "Replica", each_num = 4, tax_order_by = sum, tax_trans = "identity", my_subtitle = "Without decontamination")
```

Overlap of all 4 methods

```{r}
#| fig-width: 10
#| fig-height: 7
#| fig-lightbox: true
taxa_rep1 <- taxa_names(pseq_restrictive) %>% 
  intersect(taxa_names(pseq_decontam)) %>% 
  intersect(taxa_names(pseq_SCRuB)) %>% 
  intersect(taxa_names(pseq_Nj))
taxa_rep2 <- taxa_names(rep_restrictive) %>% 
  intersect(taxa_names(rep_decontam)) %>% 
  intersect(taxa_names(rep_SCRuB)) %>% 
  intersect(taxa_names(rep_Nj))
#taxa_core <- intersect(taxa_rep1, taxa_rep2)

pseq_rep1 <- pseq_raw %>% 
  prune_taxa(taxa_names(.) %in% taxa_rep1, .) %>% 
  prune_samples(sample_sums(.) >0, .)
pseq_rep2 <- rep_raw %>% 
  prune_taxa(taxa_names(.) %in% taxa_rep2, .) %>% 
  prune_samples(sample_sums(.) >0, .)

ps_all_merged <- merge_phyloseq(
  pseq_rep1 %>% ps_mutate(Replica = "R1") %>% ps_arrange(AN_NR),
  pseq_rep2 %>% ps_mutate(Replica = "R2") %>% ps_arrange(AN_NR)
)
ps_all_merged %>% 
  rarefy_even_depth(sample.size = 6640) %>% 
  CompositionalPlot_Viz_v03(supper_rank = "phylum", smaller_rank = "family", supper_rank_list = c("Bacillota", "Bacteroidota", "Pseudomonadota"), facet = "Replica", each_num = 4, tax_order_by = sum, tax_trans = "identity", my_subtitle = "All decontamination")
```

```{r}
#| fig-width: 10
#| fig-height: 7
#| fig-lightbox: true

CompositionalPlot_Viz_v03(PhyloseqObj = ps_all_merged, supper_rank = "class", smaller_rank = "genus", supper_rank_list = c("Clostridia", "Bacilli", "Bacteroidia"), facet = "Replica", each_num = 4, tax_order_by = sum, tax_trans = "identity", my_subtitle = "All decontamination")
```

Test

```{r}
PhyloseqObj = ps_all_merged
supper_rank = "phylum" ##"phylum"
smaller_rank =  "family" ##"family"
target_taxa_name = select_name
#supper_rank_list = c("Clostridia", "Bacilli", "Bacteroidia") ##c("Bacillota", "Bacteroidota", "Pseudomonadota")
n_super_rank = 3
facet = "Replica"
each_num = 4
tax_order_by = sum
my_subtitle = "NJ decontamination"

hueRank <- supper_rank
hueRankPlural <- switch (hueRank,
  "phylum" = "phyla",
  "class" = "classes",
  "order" = "orders",
  "family" = "families",
  "genus" = "genera"
)
shadeRank <- smaller_rank
my_order <- supper_rank_list

# Sort phyloseq at lower, and then higher ranks
pseq2 <- PhyloseqObj %>%
  #ps_filter(gender == "male") %>%
  tax_sort(by = tax_order_by, at = shadeRank) %>%
  tax_sort(by = tax_order_by, at = hueRank) %>%
  tax_agg(rank = shadeRank)

## sort taxa
# tax_tbl <- tax_tibble(pseq2) %>%
#   dplyr::arrange(match(.data[[hueRank]], my_order)) %>%
#   remove_rownames() %>%
#   column_to_rownames(var = "FeatureID")
# pseq2 <- pseq2 %>%
#   tax_reorder(tax_order = rownames(tax_tbl))

# Specify number of hues and shades desired
nHues <-n_super_rank  ##length(supper_rank_list) # "Other" phyla will be shades of grey
nShades <- each_num # "Other" families will be the lightest shade of each hue

hierarchicalPalInfo <- data.frame(
  hue = as.vector(tt_get(pseq2)[, hueRank]),
  shade = as.vector(tt_get(pseq2)[, shadeRank]),
  counts = taxa_sums(otu_get(pseq2))
)

hierarchicalPalInfo <- hierarchicalPalInfo %>%
  dplyr::mutate(
    hue = forcats::fct_other(
      f = hue, keep = unique(hue)[seq_len(nHues)],
      other_level = paste("Other", hueRankPlural)
    ),
    nChrHue = nchar(as.character(hue)), padHue = max(nChrHue) - nChrHue
  ) %>%
  dplyr::group_by(hue) %>%
  dplyr::mutate(
    shade = forcats::fct_other(
      f = shade, keep = unique(shade)[seq_len(nShades - 1)],
      other_level = "Other"
    )
  ) %>%
  dplyr::mutate(n_shades = length(unique(shade))) %>%
  dplyr::ungroup() %>%
  dplyr::mutate(
    nChrShade = nchar(as.character(shade)), padShade = max(nChrShade) - nChrShade,
    Taxa = paste0(hue, ": ", strrep(" ", padHue), shade, strrep(" ", padShade))
  )

hierarchicalPalMatrix <- matrix(
data = sapply(
  X = seq(from = 30, to = 75, length.out = nShades),
  FUN = function(l) scales::hue_pal(l = l, h.start = 30)(n = nHues)
  ),
  byrow = TRUE, ncol = nHues
)

hierarchicalPalMatrix <- cbind(hierarchicalPalMatrix, grey.colors(n = nShades))

## remove some of shade if there is not enough taxa
#mask_matrix <- matrix(data = 1, nrow = nrow(hierarchicalPalMatrix), ncol = ncol(hierarchicalPalMatrix))
v <- hierarchicalPalInfo[, c("hue", "n_shades")] %>% unique() %>% pull(n_shades)
hierarchicalPalMatrix[row(hierarchicalPalMatrix) > rep(v, each = nrow(hierarchicalPalMatrix))] <- NA


hierarchicalPal <- hierarchicalPalMatrix %>%
  as.vector() %>%
  na.omit() %>%
  setNames(unique(hierarchicalPalInfo$Taxa))

col_nm <- sprintf("%s: %s", hueRank, shadeRank)
plt <- pseq2 %>%
  ps_get() %>%
  #tax_mutate("Phylum: Family" = hierarchicalPalInfo$Taxa, .keep = "none") %>%
  tax_mutate(!!col_nm := hierarchicalPalInfo$Taxa, .keep = "none") %>%
  tax_transform("compositional") %>%
  #ps_arrange(desc(!!sym(target_taxa_name)), .target = "otu_table") %>%
  comp_barplot(
    tax_level = col_nm, n_taxa = length(hierarchicalPal),
    #tax_order = "asis",
    sample_order = "asis", counts_warn = FALSE,
    tax_order = "asis",
    palette = hierarchicalPal, bar_width = 0.975
  ) +
  coord_flip() +
  #ggtitle(paste0(my_title)) +
  #theme(legend.text = element_text(family = "mono")) # for text alignment
  facet_wrap(facet, nrow = 1, scales = "free") +
  labs(x = NULL, y = NULL,
       title = my_title,
      subtitle = my_subtitle) +
  theme(axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        text = element_text(size = 14),
        plot.title = element_text(size=16, face="bold"))
## test
plt <- pseq2 %>%
  tax_mutate(!!col_nm := hierarchicalPalInfo$Taxa, .keep = "none") %>%
  ps_arrange(AN_NR) %>%
  ps_mutate(AN_NR = factor(AN_NR, rev(unique(AN_NR)))) %>%
  comp_barplot(
    tax_level = col_nm, n_taxa = length(hierarchicalPal),
    sample_order = "asis", x = "AN_NR",
    tax_order = "asis",
    palette = hierarchicalPal, bar_width = 0.975
  ) +
  facet_wrap(facets = vars(Replica), scales = "fixed") +
  coord_flip() +
  labs( x= "Sample ID", y = "Relative abundance") +
  scale_y_continuous(expand = expansion(add = c(0, 0.05))) + # axis starts exactly at 0
  theme_bw() + # slightly clearer axes for facets
  theme(panel.spacing.x = unit(6, "mm")) # space for non-overlapping axis numbers
print(plt)
```

Class - Genus

```{r}
#| fig-width: 10
#| fig-height: 7
#| fig-lightbox: true

CompositionalPlot_Viz_v03(PhyloseqObj = ps_all_merged, supper_rank = "class", smaller_rank = "genus", supper_rank_list = c("Clostridia", "Bacilli", "Bacteroidia"), facet = "Replica", each_num = 4, tax_order_by = sum, my_subtitle = "All decontamination")
```

Other

```{r}
# PhyloseqObj = ps_NJ_merged
# supper_rank = "phylum"
# smaller_rank = "family"
# target_taxa_name = select_name
# supper_rank_list = c("Bacillota", "Bacteroidota", "Pseudomonadota")
# facet = "Replica"
# each_num = 4
# tax_order_by = sum
# my_subtitle = "NJ decontamination"
# 
# hueRank <- supper_rank
# hueRankPlural <- switch (hueRank,
#   "phylum" = "phyla",
#   "class" = "classes",
#   "order" = "orders",
#   "family" = "families",
#   "genus" = "genera"
# )
# shadeRank <- smaller_rank
# my_order <- supper_rank_list
# 
# # Sort phyloseq at lower, and then higher ranks
# pseq2 <- PhyloseqObj %>%
#   #ps_filter(gender == "male") %>%
#   tax_sort(by = tax_order_by, at = shadeRank) %>%
#   tax_sort(by = tax_order_by, at = hueRank) %>%
#   tax_agg(rank = shadeRank)
# 
# ## sort taxa
# tax_tbl <- tax_tibble(pseq2) %>% 
#   dplyr::arrange(match(.data[[hueRank]], my_order)) %>% 
#   remove_rownames() %>% 
#   column_to_rownames(var = "FeatureID")
# pseq2 <- pseq2 %>% 
#   tax_reorder(tax_order = rownames(tax_tbl))
# 
# # Specify number of hues and shades desired
# nHues <- length(supper_rank_list) # "Other" phyla will be shades of grey
# nShades <- each_num # "Other" families will be the lightest shade of each hue
# 
# hierarchicalPalInfo <- data.frame(
#   hue = as.vector(tt_get(pseq2)[, hueRank]),
#   shade = as.vector(tt_get(pseq2)[, shadeRank]),
#   counts = taxa_sums(otu_get(pseq2))
# )
# 
# hierarchicalPalInfo <- hierarchicalPalInfo %>%
#   dplyr::mutate(
#     hue = forcats::fct_other(
#       f = hue, keep = unique(hue)[seq_len(nHues)],
#       other_level = paste("Other", hueRankPlural)
#     ),
#     nChrHue = nchar(as.character(hue)), padHue = max(nChrHue) - nChrHue
#   ) %>%
#   dplyr::group_by(hue) %>%
#   dplyr::mutate(
#     shade = forcats::fct_other(
#       f = shade, keep = unique(shade)[seq_len(nShades - 1)],
#       other_level = "Other"
#     )
#   ) %>%
#   dplyr::ungroup() %>%
#   dplyr::mutate(
#     nChrShade = nchar(as.character(shade)), padShade = max(nChrShade) - nChrShade,
#     Taxa = paste0(hue, ": ", strrep(" ", padHue), shade, strrep(" ", padShade))
#   )
# 
# hierarchicalPalMatrix <- matrix(
# data = sapply(
#   X = seq(from = 30, to = 75, length.out = nShades),
#   FUN = function(l) scales::hue_pal(l = l, h.start = 30)(n = nHues)
#   ),
#   byrow = TRUE, ncol = nHues
# )
# hierarchicalPalMatrix <- cbind(hierarchicalPalMatrix, grey.colors(n = nShades))
# 
# hierarchicalPal <- hierarchicalPalMatrix %>%
#   as.vector() %>%
#   setNames(unique(hierarchicalPalInfo$Taxa))
# 
# col_nm <- sprintf("%s: %s", hueRank, shadeRank)
# plt <- pseq2 %>%
#   ps_get() %>%
#   #tax_mutate("Phylum: Family" = hierarchicalPalInfo$Taxa, .keep = "none") %>%
#   tax_mutate(!!col_nm := hierarchicalPalInfo$Taxa, .keep = "none") %>%
#   tax_transform("compositional") %>%
#   #ps_arrange(desc(!!sym(target_taxa_name)), .target = "otu_table") %>% 
#   comp_barplot(
#     tax_level = col_nm, n_taxa = length(hierarchicalPal),
#     #tax_order = "asis",
#     sample_order = "asis", counts_warn = FALSE,
#     tax_order = "asis", 
#     palette = hierarchicalPal, bar_width = 0.975
#   ) +
#   coord_flip() +
#   #ggtitle(paste0(my_title)) +
#   #theme(legend.text = element_text(family = "mono")) # for text alignment
#   facet_wrap(facet, nrow = 1, scales = "free") +
#   labs(x = NULL, y = NULL,
#        title = my_title,
#       subtitle = my_subtitle) +
#   theme(axis.text.y = element_blank(), 
#         axis.ticks.y = element_blank(),
#         text = element_text(size = 14),
#         plot.title = element_text(size=16, face="bold"))
# ## test
# plt <- pseq2 %>% 
#   tax_mutate(!!col_nm := hierarchicalPalInfo$Taxa, .keep = "none") %>% 
#   ps_arrange(AN_NR) %>% 
#   ps_mutate(AN_NR = factor(AN_NR, levels = unique(AN_NR)),
#             Replica = factor(Replica, levels = unique(Replica))
#             ) %>% 
#   comp_barplot(
#     tax_level = col_nm, n_taxa = length(hierarchicalPal),
#     sample_order = "asis", 
#     x = "Replica",
#     tax_order = "asis",
#     palette = hierarchicalPal, bar_width = 0.975
#   ) +
#   facet_wrap(facets = vars(AN_NR)) +
#   coord_flip() +
#   labs( x= "Sample ID", y = "Relative abundance") +
#   scale_y_continuous(expand = expansion(add = c(0, 0.05))) + # axis starts exactly at 0
#   theme_bw() + # slightly clearer axes for facets
#   theme(panel.spacing.x = unit(6, "mm")) # space for non-overlapping axis numbers
# print(plt)
```
